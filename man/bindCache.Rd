% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bind-cache.R
\name{bindCache}
\alias{bindCache}
\title{Add caching with reactivity to an object}
\usage{
bindCache(x, ..., cache = "app")
}
\arguments{
\item{x}{The object to add caching to.}

\item{...}{One or more expressions to use in the caching key.}

\item{cache}{The scope of the cache, or a cache object. This can be \code{"app"}
(the default), \code{"session"}, or a cache object like a \code{\link[cachem:cache_disk]{cachem::cache_disk()}}.
See the Cache Scoping section for more information.}
}
\description{
\code{bindCache()} adds caching to the following kinds of objects used in Shiny:
\itemize{
\item \code{\link[=reactive]{reactive()}}` expressions.
\item \verb{render*} functions, like \code{\link[=renderText]{renderText()}}, \code{\link[=renderTable]{renderTable()}}, and so on.
}

It is often used in conjunction with \code{\link[=bindEvent]{bindEvent()}}.

Ordinary \code{\link[=reactive]{reactive()}} expressions will cache their most recent value. This
can make computation more efficient, because time-consuming code can execute
once and the result can be used in multiple different places without needing
to re-execute the code.

When \code{bindCache()} is used on a reactive expression, any number of previous
values can be cached. You must provide one or more expressions that are used
to generate a \emph{cache key}. The \code{...} expressions are put together in a list
and hashed, and the result is used as the cache \strong{key}.

There is also a \strong{value} expression, which is the expression passed to the
original reactive.

For each possible \strong{key}, there should be one possible \strong{value} returned by
the original reactive expression; a given key should not correspond to
multiple possible values from the reactive expression.

To use `bindCache(), the key should be fast to compute, and the value should
expensive (so that it benefits from caching).  To see the value should be
computed, a cached reactive evaluates the key, and then serializes and hashes
the result. If the resulting hashed key is in the cache, then the cached
reactive simply retrieves the previously calculated value and returns it; if
not, then the value is computed and the result is stored in the cache before
being returned.

The key should be fast to compute, and ideally it will return an object that
is not too large, so that serializing and hashing the object is not
expensive.

In most cases, the key will contain any reactive inputs that are used by the
value expression. It is also best to use non-reference objects, since the
serialization of these objects may not capture relevant changes.
}
\section{Cache keys and reactivity}{


Because the \strong{value} expression (from the original \code{\link[=reactive]{reactive()}}) is
cached, it is not necessarily re-executed when someone retrieves a value,
and therefore it can't be used to decide what objects to take reactive
dependencies on. Instead, the \strong{key} is used to figure out which objects
to take reactive dependencies on. In short, the key expression is reactive,
and value expression is no longer reactive.

Here's an example of what not to do: if the key is \code{input$x} and the value
expression is from \code{reactive({input$x + input$y})}, then the resulting
cached reactive  will only take a reactive dependency on \code{input$x} -- it
won't recompute \code{{input$x + input$y}} when just \code{input$y} changes.
Moreover, the cache won't use \code{input$y} as part of the key, and so it could
return incorrect values in the future when it retrieves values from the
cache. (See the examples below for an example of this.)

A better cache key would be something like \verb{input$x, input$y}. This does
two things: it ensures that a reactive dependency is taken on both
\code{input$x} and \code{input$y}, and it also makes sure that both values are
represented in the cache key.

In general, \code{key} should use the same reactive inputs as \code{value}, but the
computation should be simpler. If there are other (non-reactive) values
that are consumed, such as external data sources, they should be used in
the \code{key} as well. Note that if the \code{key} is large, it can make sense to do
some sort of reduction on it so that the serialization and hashing of the
cache key is not too expensive.

Remember that the key is \emph{reactive}, so it is not re-executed every single
time that someone accesses the cached reactive. It is only re-executed if
it has been invalidated by one of the reactives it depends on.. For
example, suppose we have this cached reactive:\if{html}{\out{<div class="NA">}}\preformatted{r <- cachedReactive(
 reactive(\{ input$x + input$y \}),
 input$x, input$y
)
}\if{html}{\out{</div>}}

In this case, the key expression is essentially \code{reactive(list(input$x, input$y))} (there's a bit more to it, but that's a good enough
approximation). The first time \code{r()} is called, it executes the key, then
fails to find it in the cache, so it executes the value expression, \code{{ input$x + input$y }}. If \code{r()} is called again, then it does not need to
re-execute the key expression, because it has not been invalidated via a
change to \code{input$x} or \code{input$y}; it simply returns the previous value.
However, if \code{input$x} or \code{input$y} changes, then the reactive expression will
be invalidated, and the next time that someone calls \code{r()}, the key
expression will need to be re-executed.

Note that if the cached reactive is passed to \code{\link[=bindEvent]{bindEvent()}}, then the key
expression will no longer be reactive; instead, the event expression will
be reactive.
}

\section{Async with cached reactives}{


With a cached reactive expression, the key and/or value expression can be
\emph{asynchronous}. In other words, they can be promises -- not regular R
promises, but rather objects provided by the \pkg{promises}  package, which
are similar to promises in JavaScript. (See \code{\link[promises:promise]{promises::promise()}} for more
information.) You can also use \code{\link[future:future]{future::future()}} objects to run code in a
separate process or even on a remote machine.

If the value returns a promise, then anything that consumes the cached
reactive must expect it to return a promise.

Similarly, if the key is a promise (in other words, if it is asynchronous),
then the entire cached reactive must be asynchronous, since the key must be
computed asynchronously before it knows whether to compute the value or the
value is retrieved from the cache. Anything that consumes the cached
reactive must therefore expect it to return a promise.
}

\section{Cache scope}{


By default, a cached reactive is scoped to the running application. That
means that it shares a cache with all user sessions connected to the
application (within the R process). This is done with the \code{cache}
parameter's default value, \code{"app"}.

With an app-level cache scope, one user can benefit from the work done for
another user's session. In most cases, this is the best way to get
performance improvements from caching. However, in some cases, this could
leak information between sessions. For example, if a user sees that a cached
reactive returns its value very quickly, they may be able to infer that
someone else has already used it with the same values. Or if the cache key
does not fully encompass the inputs used by the value, then data could leak
between the sessions.

It is also possible to scope the cache to the session, with
\code{cache="session"}. This removes the risk of information leaking between
sessions, but then one session cannot benefit from computations performed in
another session.

Finally, it is possible to pass in caching objects directly to
\code{bindCache()}. This can be useful if, for example, you want to use a
particular type of cache with specific cached reactives.
}

\section{Cache key internals}{


The actual cache key that is used internally takes value from evaluating the
key expression(s) and combines it with the (unevaluated) value expression.

This means that if there are two cached reactives which have the same result
from evaluating the key, but different value expressions, then they will not
need to worry about collisions.

However, if two cached reactives have identical key and value expressions
expressions, they will share the cached values. This is useful when using
\code{cache="app"}: there may be multiple user sessions which create separate
cached reactive objects (because they are created from the same code in the
server function, but the server function is executed once for each user
session), and those cached reactive objects across sessions can share values
in the cache.
}

\examples{
\dontrun{
rc <- bindCache(
  x = reactive({
    Sys.sleep(2)   # Pretend this is expensive
    input$x * 100
  }),
  input$x
)

# Can make it prettier with the \%>\% operator
library(magrittr)

rc <- reactive({
  Sys.sleep(2)
  input$x * 100
}) \%>\%
  bindCache(input$x)

}

## Only run app examples in interactive R sessions
if (interactive()) {

# Basic example
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      # The value expression is an _expensive_ computation
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)

    output$txt <- renderText(r())
  }
)


# Caching renderText
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    output$txt <- renderText({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y)
  }
)


# Demo of using events and caching with an actionButton
shinyApp(
  ui = fluidPage(
    sliderInput("x", "x", 1, 10, 5),
    sliderInput("y", "y", 1, 10, 5),
    actionButton("go", "Go"),
    div("x * y: "),
    verbatimTextOutput("txt")
  ),
  server = function(input, output) {
    r <- reactive({
      message("Doing expensive computation...")
      Sys.sleep(2)
      input$x * input$y
    }) \%>\%
      bindCache(input$x, input$y) \%>\%
      bindEvent(input$go)
      # The cached, eventified reactive takes a reactive dependency on
      # input$go, but doesn't use it for the cache key. It uses input$x and
      # input$y for the cache key, but doesn't take a reactive depdency on
      # them, because the reactive dependency is superseded by addEvent().

    output$txt <- renderText(r())
  }
)

}

}
\seealso{
\code{\link[=bindEvent]{bindEvent()}}
}
